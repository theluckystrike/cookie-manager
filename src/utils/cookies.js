/**
 * Cookie Manager - Cookie Utilities
 * Handles all Chrome cookies API interactions
 */

export const CookieManager = {
    /**
     * Get all cookies for a specific URL
     * @param {string} url - The URL to get cookies for
     * @returns {Promise<chrome.cookies.Cookie[]>}
     */
    async getAll(url) {
        try {
            const domain = new URL(url).hostname;
            return await chrome.cookies.getAll({ domain });
        } catch (error) {
            console.error('[CookieManager] Error getting cookies:', error);
            return [];
        }
    },

    /**
     * Get all cookies across all domains
     * @returns {Promise<chrome.cookies.Cookie[]>}
     */
    async getAllGlobal() {
        try {
            return await chrome.cookies.getAll({});
        } catch (error) {
            console.error('[CookieManager] Error getting global cookies:', error);
            return [];
        }
    },

    /**
     * Get a specific cookie
     * @param {string} url - The URL
     * @param {string} name - Cookie name
     * @returns {Promise<chrome.cookies.Cookie|null>}
     */
    async get(url, name) {
        try {
            return await chrome.cookies.get({ url, name });
        } catch (error) {
            console.error('[CookieManager] Error getting cookie:', error);
            return null;
        }
    },

    /**
     * Set/update a cookie
     * @param {Object} cookie - Cookie details
     * @returns {Promise<chrome.cookies.Cookie|null>}
     */
    async set(cookie) {
        try {
            const { domain, ...rest } = cookie;
            const cleanDomain = domain.startsWith('.') ? domain.slice(1) : domain;
            const url = `http${cookie.secure ? 's' : ''}://${cleanDomain}${cookie.path || '/'}`;

            return await chrome.cookies.set({
                url,
                domain,
                ...rest
            });
        } catch (error) {
            console.error('[CookieManager] Error setting cookie:', error);
            return null;
        }
    },

    /**
     * Delete a cookie
     * @param {string} url - The URL
     * @param {string} name - Cookie name
     * @returns {Promise<Object|null>}
     */
    async remove(url, name) {
        try {
            return await chrome.cookies.remove({ url, name });
        } catch (error) {
            console.error('[CookieManager] Error removing cookie:', error);
            return null;
        }
    },

    /**
     * Clear all cookies for a domain
     * @param {string} domain - Domain to clear
     * @returns {Promise<number>} - Number of cookies deleted
     */
    async clearDomain(domain) {
        try {
            const cookies = await this.getAll(`https://${domain}`);
            let count = 0;

            for (const cookie of cookies) {
                const cookieDomain = cookie.domain.startsWith('.')
                    ? cookie.domain.slice(1)
                    : cookie.domain;
                const url = `http${cookie.secure ? 's' : ''}://${cookieDomain}${cookie.path}`;
                await this.remove(url, cookie.name);
                count++;
            }

            return count;
        } catch (error) {
            console.error('[CookieManager] Error clearing domain:', error);
            return 0;
        }
    },

    /**
     * Export cookies as JSON
     * @param {chrome.cookies.Cookie[]} cookies
     * @returns {string}
     */
    toJSON(cookies) {
        return JSON.stringify(cookies, null, 2);
    },

    /**
     * Export cookies as Netscape format (for curl, etc)
     * @param {chrome.cookies.Cookie[]} cookies
     * @returns {string}
     */
    toNetscape(cookies) {
        const lines = ['# Netscape HTTP Cookie File', '# Generated by Cookie Manager (zovo.one)'];

        for (const c of cookies) {
            const httpOnly = c.httpOnly ? '#HttpOnly_' : '';
            const domain = c.domain.startsWith('.') ? c.domain : `.${c.domain}`;
            const flag = c.domain.startsWith('.') ? 'TRUE' : 'FALSE';
            const secure = c.secure ? 'TRUE' : 'FALSE';
            const expiry = c.expirationDate ? Math.floor(c.expirationDate) : '0';

            lines.push(`${httpOnly}${domain}\t${flag}\t${c.path}\t${secure}\t${expiry}\t${c.name}\t${c.value}`);
        }

        return lines.join('\n');
    },

    /**
     * Parse cookie string (from document.cookie format)
     * @param {string} cookieString
     * @returns {Object[]}
     */
    parse(cookieString) {
        if (!cookieString) return [];

        return cookieString.split(';').map(pair => {
            const [name, ...valueParts] = pair.trim().split('=');
            return { name: name.trim(), value: valueParts.join('=') };
        }).filter(c => c.name);
    },

    /**
     * Build URL from cookie properties
     * @param {chrome.cookies.Cookie} cookie
     * @returns {string}
     */
    buildUrl(cookie) {
        const domain = cookie.domain.startsWith('.')
            ? cookie.domain.slice(1)
            : cookie.domain;
        return `http${cookie.secure ? 's' : ''}://${domain}${cookie.path || '/'}`;
    }
};
